name: Release

on:
  push:
    tags:
      - 'v*'

env:
  CARGO_TERM_COLOR: always
  # Library versions - update these when upgrading
  # ONNX Runtime 1.23+ requires CUDA 12.x and cuDNN 9.x
  ONNXRUNTIME_VERSION: "1.23.2"
  # CUDA redistributable versions (from https://developer.download.nvidia.com/compute/cuda/redist/redistrib_12.9.0.json)
  CUDA_CUDART_VERSION: "12.9.37"
  CUDA_CUBLAS_VERSION: "12.9.0.13"
  CUDA_CUFFT_VERSION: "11.4.0.6"
  # cuDNN version (from https://developer.download.nvidia.com/compute/cudnn/redist/redistrib_9.17.1.json)
  CUDNN_VERSION: "9.17.1.4"
  # NVRTC and nvJitLink versions (from https://developer.download.nvidia.com/compute/cuda/redist/redistrib_12.9.0.json)
  # Required by ONNX Runtime CUDA provider for runtime kernel compilation
  CUDA_NVRTC_VERSION: "12.9.41"
  NVJITLINK_VERSION: "12.9.41"
  # TensorRT is NOT bundled due to GitHub's 2GB release asset limit
  # Users can optionally install TensorRT from https://github.com/NVIDIA/TensorRT

jobs:
  # ==========================================================================
  # Verify CI passes before building releases
  # ==========================================================================
  verify:
    name: Verify
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache cargo registry
        uses: actions/cache@v5
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ~/.cache/ort.pyke.io
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Check formatting
        run: cargo fmt --check

      - name: Run clippy
        run: cargo clippy --no-default-features -- -D warnings

      - name: Run tests
        run: cargo test --no-default-features --no-fail-fast

      - name: Verify third-party licenses file exists
        run: |
          if [ ! -f "THIRD_PARTY_LICENSES.txt" ]; then
            echo "ERROR: THIRD_PARTY_LICENSES.txt not found!"
            echo "Run the 'Update Third-Party Licenses' workflow first."
            exit 1
          fi

  # ==========================================================================
  # CPU-only builds (small, no GPU dependencies)
  # ==========================================================================
  build-cpu:
    name: Build CPU ${{ matrix.target }}
    needs: [verify]
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
            artifact: birda-linux-x64
            ext: ""

          - target: x86_64-pc-windows-msvc
            os: windows-latest
            artifact: birda-windows-x64
            ext: ".exe"

          - target: aarch64-apple-darwin
            os: macos-latest
            artifact: birda-macos-arm64
            ext: ""

    steps:
      - uses: actions/checkout@v6

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Cache cargo registry
        uses: actions/cache@v5
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ~/.cache/ort.pyke.io
            target
          key: ${{ runner.os }}-${{ matrix.target }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.target }}-cargo-

      - name: Build release binary (CPU only)
        run: cargo build --release --no-default-features --target ${{ matrix.target }}

      - name: Download ONNX Runtime (Linux)
        if: matrix.target == 'x86_64-unknown-linux-gnu'
        run: |
          mkdir -p lib-staging

          # Download ONNX Runtime CPU package
          curl -L "https://github.com/microsoft/onnxruntime/releases/download/v${{ env.ONNXRUNTIME_VERSION }}/onnxruntime-linux-x64-${{ env.ONNXRUNTIME_VERSION }}.tgz" \
            -o onnxruntime.tgz
          tar xzf onnxruntime.tgz
          cp onnxruntime-linux-x64-${{ env.ONNXRUNTIME_VERSION }}/lib/libonnxruntime.so* lib-staging/

      - name: Download ONNX Runtime (macOS ARM64)
        if: matrix.target == 'aarch64-apple-darwin'
        run: |
          mkdir -p lib-staging

          # Download ONNX Runtime CPU package
          curl -L "https://github.com/microsoft/onnxruntime/releases/download/v${{ env.ONNXRUNTIME_VERSION }}/onnxruntime-osx-arm64-${{ env.ONNXRUNTIME_VERSION }}.tgz" \
            -o onnxruntime.tgz
          tar xzf onnxruntime.tgz
          cp onnxruntime-osx-arm64-${{ env.ONNXRUNTIME_VERSION }}/lib/libonnxruntime*.dylib lib-staging/

      - name: Download ONNX Runtime (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path lib-staging

          # Download ONNX Runtime CPU package
          Invoke-WebRequest -Uri "https://github.com/microsoft/onnxruntime/releases/download/v${{ env.ONNXRUNTIME_VERSION }}/onnxruntime-win-x64-${{ env.ONNXRUNTIME_VERSION }}.zip" `
            -OutFile "onnxruntime.zip"
          Expand-Archive -Path "onnxruntime.zip" -DestinationPath "."
          Copy-Item "onnxruntime-win-x64-${{ env.ONNXRUNTIME_VERSION }}/lib/onnxruntime.dll" -Destination "lib-staging/"

      - name: Download Visual C++ Redistributable (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Download VC++ Redistributable for bundling
          # This is required by onnxruntime.dll
          Invoke-WebRequest -Uri "https://aka.ms/vs/17/release/vc_redist.x64.exe" -OutFile "vc_redist.x64.exe"
          Write-Host "Downloaded VC++ Redistributable"

      - name: Prepare artifact (Unix)
        if: runner.os != 'Windows'
        run: |
          mkdir -p dist
          cp target/${{ matrix.target }}/release/birda dist/

          # Copy ONNX Runtime next to binary
          if [ "${{ matrix.target }}" = "x86_64-unknown-linux-gnu" ]; then
            # Linux: versioned .so only - runtime finds via ORT_DYLIB_PATH
            cp lib-staging/libonnxruntime.so.${{ env.ONNXRUNTIME_VERSION }} dist/libonnxruntime.so
          elif [ "${{ matrix.target }}" = "aarch64-apple-darwin" ]; then
            # macOS: copy .dylib files
            cp lib-staging/libonnxruntime*.dylib dist/
          fi

          cp README.md dist/
          cp LICENSE dist/ 2>/dev/null || true

          # Create minimal license file for CPU build (ONNX Runtime only)
          cat > dist/THIRD_PARTY_LICENSES.txt << 'EOF'
          THIRD-PARTY SOFTWARE LICENSES
          =============================

          ONNX Runtime
          ------------
          License: MIT License
          Copyright (c) Microsoft Corporation

          https://github.com/microsoft/onnxruntime

          Permission is hereby granted, free of charge, to any person obtaining a copy
          of this software and associated documentation files (the "Software"), to deal
          in the Software without restriction, including without limitation the rights
          to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
          copies of the Software, and to permit persons to whom the Software is
          furnished to do so, subject to the following conditions:

          The above copyright notice and this permission notice shall be included in all
          copies or substantial portions of the Software.

          THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
          IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
          FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
          AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
          LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
          OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
          SOFTWARE.
          EOF

      - name: Prepare artifact (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path dist
          Copy-Item "target/${{ matrix.target }}/release/birda.exe" -Destination "dist/"

          # Copy ONNX Runtime next to binary
          Copy-Item "lib-staging/onnxruntime.dll" -Destination "dist/"

          # Copy VC++ Redistributable installer
          Copy-Item "vc_redist.x64.exe" -Destination "dist/"

          Copy-Item "README.md" -Destination "dist/"
          Copy-Item "LICENSE" -Destination "dist/" -ErrorAction SilentlyContinue

          # Create minimal license file for CPU build (ONNX Runtime only)
          @"
          THIRD-PARTY SOFTWARE LICENSES
          =============================

          ONNX Runtime
          ------------
          License: MIT License
          Copyright (c) Microsoft Corporation

          https://github.com/microsoft/onnxruntime

          Permission is hereby granted, free of charge, to any person obtaining a copy
          of this software and associated documentation files (the "Software"), to deal
          in the Software without restriction, including without limitation the rights
          to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
          copies of the Software, and to permit persons to whom the Software is
          furnished to do so, subject to the following conditions:

          The above copyright notice and this permission notice shall be included in all
          copies or substantial portions of the Software.

          THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
          IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
          FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
          AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
          LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
          OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
          SOFTWARE.
          "@ | Set-Content "dist/THIRD_PARTY_LICENSES.txt"

      - name: Upload artifact
        uses: actions/upload-artifact@v6
        with:
          name: ${{ matrix.artifact }}
          path: dist/*

  # ==========================================================================
  # Sign and notarize macOS builds
  # ==========================================================================
  sign-and-notarize-macos:
    name: Sign & Notarize macOS
    needs: [build-cpu]
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v6

      - name: Download unsigned macOS artifact
        uses: actions/download-artifact@v7
        with:
          name: birda-macos-arm64
          path: unsigned

      - name: Import code signing certificate
        uses: apple-actions/import-codesign-certs@v3
        with:
          p12-file-base64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          p12-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}

      - name: Find certificate identity
        run: |
          echo "=== Listing available signing identities ==="
          security find-identity -v -p codesigning signing_temp.keychain

          # Extract the full certificate name (between quotes)
          IDENTITY=$(security find-identity -v -p codesigning signing_temp.keychain | grep "Developer ID Application" | head -1 | awk -F'"' '{print $2}')

          if [ -z "$IDENTITY" ]; then
            echo "ERROR: No Developer ID Application certificate found!"
            exit 1
          fi

          echo "Found identity: $IDENTITY"
          echo "CERT_IDENTITY=$IDENTITY" >> $GITHUB_ENV

      - name: Sign the binary
        run: |
          echo "=== Signing binary ==="
          echo "Using identity: $CERT_IDENTITY"
          # Sign with hardened runtime and timestamp
          codesign --sign "$CERT_IDENTITY" \
            --timestamp \
            --options runtime \
            --entitlements installer/macos/entitlements.plist \
            --verbose \
            unsigned/birda

          echo "=== Verifying signature ==="
          codesign --verify --deep --strict --verbose=2 unsigned/birda
          codesign --display --verbose=4 unsigned/birda

          echo "=== Testing Gatekeeper ==="
          spctl --assess --verbose=4 --type execute unsigned/birda || echo "Note: Gatekeeper check may fail until notarized"

      - name: Sign ONNX Runtime library
        run: |
          echo "=== Signing ONNX Runtime library ==="
          for dylib in unsigned/*.dylib; do
            if [ -f "$dylib" ]; then
              echo "Processing: $dylib"

              # Check if already signed
              if codesign --verify "$dylib" 2>/dev/null; then
                echo "Already signed by: $(codesign --display --verbose "$dylib" 2>&1 | grep 'Authority=')"
                echo "Re-signing with our certificate..."
                # Use --force to replace existing signature
                codesign --force --sign "$CERT_IDENTITY" \
                  --timestamp \
                  --options runtime \
                  --verbose \
                  "$dylib"
              else
                echo "Not signed, signing now..."
                codesign --sign "$CERT_IDENTITY" \
                  --timestamp \
                  --options runtime \
                  --verbose \
                  "$dylib"
              fi

              echo "Verifying signature..."
              codesign --verify --deep --strict --verbose=2 "$dylib"
              echo "âœ“ Successfully signed: $dylib"
            fi
          done
          echo "=== All libraries signed ==="

      - name: Create ZIP for notarization
        run: |
          cd unsigned
          zip -r ../birda-notarize.zip .
          cd ..
          echo "Created notarization ZIP:"
          ls -lh birda-notarize.zip

      - name: Notarize with Apple
        run: |
          echo "=== Submitting for notarization ==="
          xcrun notarytool submit birda-notarize.zip \
            --apple-id "${{ secrets.APPLE_ID }}" \
            --password "${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}" \
            --team-id "${{ secrets.APPLE_TEAM_ID }}" \
            --wait \
            --timeout 30m \
            --verbose

          echo "=== Notarization successful ==="

      - name: Create signed tar.gz
        run: |
          VERSION="${{ github.ref_name }}"
          cd unsigned
          tar -czvf ../birda-macos-arm64-${VERSION}-signed.tar.gz *
          cd ..
          echo "Created signed tar.gz:"
          ls -lh birda-macos-arm64-${VERSION}-signed.tar.gz

      - name: Install create-dmg
        run: |
          brew install create-dmg

      - name: Create DMG
        run: |
          VERSION="${{ github.ref_name }}"
          mkdir -p dmg-staging
          cp unsigned/birda dmg-staging/
          cp unsigned/*.dylib dmg-staging/ 2>/dev/null || true
          cp unsigned/README.md dmg-staging/
          cp unsigned/LICENSE dmg-staging/ 2>/dev/null || true
          cp unsigned/THIRD_PARTY_LICENSES.txt dmg-staging/

          # Create DMG with create-dmg
          create-dmg \
            --volname "Birda ${VERSION}" \
            --volicon "dmg-staging/birda" \
            --window-pos 200 120 \
            --window-size 800 400 \
            --icon-size 100 \
            --icon "birda" 200 150 \
            --hide-extension "birda" \
            --app-drop-link 600 150 \
            "birda-macos-arm64-${VERSION}.dmg" \
            "dmg-staging/" || {
            # Fallback to hdiutil if create-dmg fails
            echo "create-dmg failed, using hdiutil"
            hdiutil create -volname "Birda ${VERSION}" -srcfolder dmg-staging -ov -format UDZO "birda-macos-arm64-${VERSION}.dmg"
          }

          echo "Created DMG:"
          ls -lh birda-macos-arm64-${VERSION}.dmg

      - name: Sign DMG
        run: |
          VERSION="${{ github.ref_name }}"
          echo "=== Signing DMG ==="
          codesign --sign "$CERT_IDENTITY" \
            --timestamp \
            --verbose \
            "birda-macos-arm64-${VERSION}.dmg"

          echo "=== Verifying DMG signature ==="
          codesign --verify --verbose "birda-macos-arm64-${VERSION}.dmg"

      - name: Notarize DMG
        run: |
          VERSION="${{ github.ref_name }}"
          echo "=== Submitting DMG for notarization ==="
          xcrun notarytool submit "birda-macos-arm64-${VERSION}.dmg" \
            --apple-id "${{ secrets.APPLE_ID }}" \
            --password "${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}" \
            --team-id "${{ secrets.APPLE_TEAM_ID }}" \
            --wait \
            --timeout 30m \
            --verbose

          echo "=== Stapling notarization to DMG ==="
          xcrun stapler staple "birda-macos-arm64-${VERSION}.dmg"

          echo "=== Verifying DMG staple ==="
          xcrun stapler validate "birda-macos-arm64-${VERSION}.dmg"

      - name: Upload signed tar.gz
        uses: actions/upload-artifact@v6
        with:
          name: birda-macos-arm64-signed
          path: birda-macos-arm64-${{ github.ref_name }}-signed.tar.gz

      - name: Upload signed DMG
        uses: actions/upload-artifact@v6
        with:
          name: birda-macos-arm64-dmg
          path: birda-macos-arm64-${{ github.ref_name }}.dmg

  # ==========================================================================
  # GPU builds with bundled ONNX Runtime + CUDA libraries
  # ==========================================================================
  build-gpu-linux:
    name: Build GPU Linux x64
    needs: [verify]
    runs-on: ubuntu-latest
    env:
      TARGET: x86_64-unknown-linux-gnu
      ARTIFACT: birda-linux-x64-cuda

    steps:
      - uses: actions/checkout@v6

      - name: Free disk space
        run: |
          echo "=== Before cleanup ==="
          df -h
          # Remove large preinstalled packages we don't need
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          echo "=== After cleanup ==="
          df -h

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ env.TARGET }}

      - name: Cache cargo registry
        uses: actions/cache@v5
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ~/.cache/ort.pyke.io
            target
          key: ${{ runner.os }}-${{ env.TARGET }}-cuda-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-${{ env.TARGET }}-cuda-cargo-

      - name: Cache GPU libraries
        uses: actions/cache@v5
        with:
          path: gpu-libs
          key: gpu-libs-linux-ort${{ env.ONNXRUNTIME_VERSION }}-cuda${{ env.CUDA_CUDART_VERSION }}-${{ env.CUDA_CUBLAS_VERSION }}-${{ env.CUDA_CUFFT_VERSION }}-cudnn${{ env.CUDNN_VERSION }}-nvrtc${{ env.CUDA_NVRTC_VERSION }}-nvjitlink${{ env.NVJITLINK_VERSION }}

      - name: Cache extracted libraries
        id: cache-libs-extracted
        uses: actions/cache@v5
        with:
          path: lib-staging
          key: lib-staging-linux-v2-ort${{ env.ONNXRUNTIME_VERSION }}-cuda${{ env.CUDA_CUDART_VERSION }}-${{ env.CUDA_CUBLAS_VERSION }}-${{ env.CUDA_CUFFT_VERSION }}-cudnn${{ env.CUDNN_VERSION }}-nvrtc${{ env.CUDA_NVRTC_VERSION }}-nvjitlink${{ env.NVJITLINK_VERSION }}

      - name: Download ONNX Runtime GPU
        if: steps.cache-libs-extracted.outputs.cache-hit != 'true'
        run: |
          mkdir -p gpu-libs
          if [ ! -f "gpu-libs/onnxruntime-linux-x64-gpu-${{ env.ONNXRUNTIME_VERSION }}.tgz" ]; then
            curl -L -o gpu-libs/onnxruntime-linux-x64-gpu-${{ env.ONNXRUNTIME_VERSION }}.tgz \
              "https://github.com/microsoft/onnxruntime/releases/download/v${{ env.ONNXRUNTIME_VERSION }}/onnxruntime-linux-x64-gpu-${{ env.ONNXRUNTIME_VERSION }}.tgz"
          fi

      - name: Download CUDA libraries
        if: steps.cache-libs-extracted.outputs.cache-hit != 'true'
        run: |
          CUDA_BASE="https://developer.download.nvidia.com/compute/cuda/redist"

          # Download all CUDA libraries in parallel
          (
            [ -f "gpu-libs/cuda_cudart.tar.xz" ] || \
            curl -L -o gpu-libs/cuda_cudart.tar.xz \
              "${CUDA_BASE}/cuda_cudart/linux-x86_64/cuda_cudart-linux-x86_64-${{ env.CUDA_CUDART_VERSION }}-archive.tar.xz"
          ) &

          (
            [ -f "gpu-libs/libcublas.tar.xz" ] || \
            curl -L -o gpu-libs/libcublas.tar.xz \
              "${CUDA_BASE}/libcublas/linux-x86_64/libcublas-linux-x86_64-${{ env.CUDA_CUBLAS_VERSION }}-archive.tar.xz"
          ) &

          (
            [ -f "gpu-libs/libcufft.tar.xz" ] || \
            curl -L -o gpu-libs/libcufft.tar.xz \
              "${CUDA_BASE}/libcufft/linux-x86_64/libcufft-linux-x86_64-${{ env.CUDA_CUFFT_VERSION }}-archive.tar.xz"
          ) &

          # NVRTC - runtime compilation library (required by ONNX Runtime CUDA provider)
          (
            [ -f "gpu-libs/cuda_nvrtc.tar.xz" ] || \
            curl -L -o gpu-libs/cuda_nvrtc.tar.xz \
              "${CUDA_BASE}/cuda_nvrtc/linux-x86_64/cuda_nvrtc-linux-x86_64-${{ env.CUDA_NVRTC_VERSION }}-archive.tar.xz"
          ) &

          # nvJitLink - JIT linking library (dependency of NVRTC)
          (
            [ -f "gpu-libs/libnvjitlink.tar.xz" ] || \
            curl -L -o gpu-libs/libnvjitlink.tar.xz \
              "${CUDA_BASE}/libnvjitlink/linux-x86_64/libnvjitlink-linux-x86_64-${{ env.NVJITLINK_VERSION }}-archive.tar.xz"
          ) &

          # Wait for all downloads to complete
          wait
          echo "All CUDA downloads complete"

      - name: Download cuDNN
        if: steps.cache-libs-extracted.outputs.cache-hit != 'true'
        run: |
          CUDNN_BASE="https://developer.download.nvidia.com/compute/cudnn/redist/cudnn/linux-x86_64"
          if [ ! -f "gpu-libs/cudnn.tar.xz" ]; then
            curl -L -o gpu-libs/cudnn.tar.xz \
              "${CUDNN_BASE}/cudnn-linux-x86_64-${{ env.CUDNN_VERSION }}_cuda12-archive.tar.xz"
          fi

      - name: Extract GPU libraries
        if: steps.cache-libs-extracted.outputs.cache-hit != 'true'
        run: |
          mkdir -p lib-staging

          # Extract ONNX Runtime (use cp -a to preserve symlinks, avoid duplicating files)
          tar -xzf gpu-libs/onnxruntime-linux-x64-gpu-${{ env.ONNXRUNTIME_VERSION }}.tgz
          cp -a onnxruntime-linux-x64-gpu-${{ env.ONNXRUNTIME_VERSION }}/lib/*.so* lib-staging/

          # Extract CUDA libraries (use cp -a to preserve symlinks)
          for archive in cuda_cudart libcublas libcufft cuda_nvrtc libnvjitlink; do
            tar -xJf gpu-libs/${archive}.tar.xz
            # Find the extracted directory and copy .so files from lib/
            for dir in ${archive}*-archive; do
              if [ -d "$dir/lib" ]; then
                cp -av "$dir"/lib/*.so* lib-staging/ 2>/dev/null || true
              fi
            done
          done

          # Extract cuDNN (use cp -a to preserve symlinks)
          tar -xJf gpu-libs/cudnn.tar.xz
          for dir in cudnn*-archive; do
            if [ -d "$dir/lib" ]; then
              cp -av "$dir"/lib/*.so* lib-staging/ 2>/dev/null || true
            fi
          done

          # Note: TensorRT is NOT bundled due to GitHub's 2GB release asset limit
          # Users can optionally download from https://github.com/NVIDIA/TensorRT

          # List what we collected
          echo "=== Collected libraries ==="
          ls -la lib-staging/

          # Verify critical libraries were extracted
          REQUIRED_LIBS=(
            "libonnxruntime.so"
            "libonnxruntime_providers_cuda.so"
            "libonnxruntime_providers_shared.so"
            "libcudart.so"
            "libcublas.so"
            "libcublasLt.so"
            "libcufft.so"
            "libcudnn.so"
            "libnvrtc.so"
            "libnvJitLink.so"
          )

          for lib in "${REQUIRED_LIBS[@]}"; do
            if ! ls lib-staging/${lib}* 1> /dev/null 2>&1; then
              echo "ERROR: Required library ${lib} not found!"
              exit 1
            fi
          done

          echo "All required libraries present"

          # Clean up extracted directories to save space (keep only lib-staging)
          rm -rf cuda_cudart*-archive libcublas*-archive libcufft*-archive cuda_nvrtc*-archive libnvjitlink*-archive cudnn*-archive
          rm -rf onnxruntime-linux-x64-gpu-*

          # Delete remaining downloaded archives to free disk space
          rm -rf gpu-libs/
          echo "Disk space after cleanup:"
          df -h .

      - name: Build release binary (CUDA)
        env:
          ORT_LIB_LOCATION: ${{ github.workspace }}/lib-staging
        run: cargo build --release --features cuda --target ${{ env.TARGET }}

      - name: Prepare artifact
        run: |
          mkdir -p dist

          # Copy binary
          cp target/${{ env.TARGET }}/release/birda dist/

          # Copy all GPU libraries preserving symlinks
          # Using -P to preserve symlinks (e.g., libcudart.so.12 -> libcudart.so.12.9.37)
          # This ensures the binary finds the specific SONAME it was linked against
          cp -P lib-staging/*.so* dist/

          # Copy documentation
          cp README.md dist/
          cp LICENSE dist/ 2>/dev/null || true
          cp THIRD_PARTY_LICENSES.txt dist/

          # Show what will be archived and total size
          echo "=== Contents of dist/ ==="
          find dist -type f -exec ls -lh {} \;
          echo "=== Total size ==="
          du -sh dist/

          # Create archive with gzip compression (include version in filename)
          cd dist && tar -czvf ../${{ env.ARTIFACT }}-${{ github.ref_name }}.tar.gz *

      - name: Upload artifact
        uses: actions/upload-artifact@v6
        with:
          name: ${{ env.ARTIFACT }}
          path: ${{ env.ARTIFACT }}-${{ github.ref_name }}.tar.gz

  build-gpu-windows:
    name: Build GPU Windows x64
    needs: [verify]
    runs-on: windows-latest
    env:
      TARGET: x86_64-pc-windows-msvc
      ARTIFACT: birda-windows-x64-cuda

    steps:
      - uses: actions/checkout@v6

      - name: Free disk space
        shell: pwsh
        run: |
          Write-Host "=== Before cleanup ==="
          Get-PSDrive -PSProvider FileSystem | Select-Object Name, @{N='Free(GB)';E={[math]::Round($_.Free/1GB,2)}}
          # Remove large preinstalled packages we don't need
          Remove-Item -Recurse -Force "C:\Program Files\dotnet" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "C:\Android" -ErrorAction SilentlyContinue
          Write-Host "=== After cleanup ==="
          Get-PSDrive -PSProvider FileSystem | Select-Object Name, @{N='Free(GB)';E={[math]::Round($_.Free/1GB,2)}}

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ env.TARGET }}

      - name: Cache cargo registry
        uses: actions/cache@v5
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ~/.cache/ort.pyke.io
            target
          key: ${{ runner.os }}-${{ env.TARGET }}-cuda-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-${{ env.TARGET }}-cuda-cargo-

      - name: Cache GPU libraries
        uses: actions/cache@v5
        with:
          path: gpu-libs
          key: gpu-libs-windows-ort${{ env.ONNXRUNTIME_VERSION }}-cuda${{ env.CUDA_CUDART_VERSION }}-${{ env.CUDA_CUBLAS_VERSION }}-${{ env.CUDA_CUFFT_VERSION }}-cudnn${{ env.CUDNN_VERSION }}-nvrtc${{ env.CUDA_NVRTC_VERSION }}-nvjitlink${{ env.NVJITLINK_VERSION }}

      - name: Cache extracted libraries
        id: cache-libs-extracted
        uses: actions/cache@v5
        with:
          path: lib-staging
          key: lib-staging-windows-v2-ort${{ env.ONNXRUNTIME_VERSION }}-cuda${{ env.CUDA_CUDART_VERSION }}-${{ env.CUDA_CUBLAS_VERSION }}-${{ env.CUDA_CUFFT_VERSION }}-cudnn${{ env.CUDNN_VERSION }}-nvrtc${{ env.CUDA_NVRTC_VERSION }}-nvjitlink${{ env.NVJITLINK_VERSION }}

      - name: Download ONNX Runtime GPU
        if: steps.cache-libs-extracted.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path gpu-libs
          $ortFile = "gpu-libs/onnxruntime-win-x64-gpu-${{ env.ONNXRUNTIME_VERSION }}.zip"
          if (-not (Test-Path $ortFile)) {
            Invoke-WebRequest -Uri "https://github.com/microsoft/onnxruntime/releases/download/v${{ env.ONNXRUNTIME_VERSION }}/onnxruntime-win-x64-gpu-${{ env.ONNXRUNTIME_VERSION }}.zip" -OutFile $ortFile
          }

      - name: Download CUDA libraries
        if: steps.cache-libs-extracted.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          $cudaBase = "https://developer.download.nvidia.com/compute/cuda/redist"

          # CUDA Runtime
          if (-not (Test-Path "gpu-libs/cuda_cudart.zip")) {
            Invoke-WebRequest -Uri "${cudaBase}/cuda_cudart/windows-x86_64/cuda_cudart-windows-x86_64-${{ env.CUDA_CUDART_VERSION }}-archive.zip" -OutFile "gpu-libs/cuda_cudart.zip"
          }

          # cuBLAS
          if (-not (Test-Path "gpu-libs/libcublas.zip")) {
            Invoke-WebRequest -Uri "${cudaBase}/libcublas/windows-x86_64/libcublas-windows-x86_64-${{ env.CUDA_CUBLAS_VERSION }}-archive.zip" -OutFile "gpu-libs/libcublas.zip"
          }

          # cuFFT
          if (-not (Test-Path "gpu-libs/libcufft.zip")) {
            Invoke-WebRequest -Uri "${cudaBase}/libcufft/windows-x86_64/libcufft-windows-x86_64-${{ env.CUDA_CUFFT_VERSION }}-archive.zip" -OutFile "gpu-libs/libcufft.zip"
          }

          # NVRTC - runtime compilation library (required by ONNX Runtime CUDA provider)
          if (-not (Test-Path "gpu-libs/cuda_nvrtc.zip")) {
            Invoke-WebRequest -Uri "${cudaBase}/cuda_nvrtc/windows-x86_64/cuda_nvrtc-windows-x86_64-${{ env.CUDA_NVRTC_VERSION }}-archive.zip" -OutFile "gpu-libs/cuda_nvrtc.zip"
          }

          # nvJitLink - JIT linking library (dependency of NVRTC)
          if (-not (Test-Path "gpu-libs/libnvjitlink.zip")) {
            Invoke-WebRequest -Uri "${cudaBase}/libnvjitlink/windows-x86_64/libnvjitlink-windows-x86_64-${{ env.NVJITLINK_VERSION }}-archive.zip" -OutFile "gpu-libs/libnvjitlink.zip"
          }

      - name: Download cuDNN
        if: steps.cache-libs-extracted.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          if (-not (Test-Path "gpu-libs/cudnn.zip")) {
            Invoke-WebRequest -Uri "https://developer.download.nvidia.com/compute/cudnn/redist/cudnn/windows-x86_64/cudnn-windows-x86_64-${{ env.CUDNN_VERSION }}_cuda12-archive.zip" -OutFile "gpu-libs/cudnn.zip"
          }

      - name: Extract GPU libraries
        if: steps.cache-libs-extracted.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path lib-staging

          # Extract ONNX Runtime
          Expand-Archive -Path "gpu-libs/onnxruntime-win-x64-gpu-${{ env.ONNXRUNTIME_VERSION }}.zip" -DestinationPath "ort-extract" -Force
          Copy-Item "ort-extract/onnxruntime-win-x64-gpu-${{ env.ONNXRUNTIME_VERSION }}/lib/*.dll" -Destination "lib-staging/" -ErrorAction SilentlyContinue

          # Extract CUDA libraries (including nvrtc and nvjitlink)
          @("cuda_cudart", "libcublas", "libcufft", "cuda_nvrtc", "libnvjitlink") | ForEach-Object {
            $name = $_
            Expand-Archive -Path "gpu-libs/${name}.zip" -DestinationPath "${name}-extract" -Force
            Get-ChildItem -Path "${name}-extract" -Recurse -Filter "*.dll" | Copy-Item -Destination "lib-staging/" -ErrorAction SilentlyContinue
          }

          # Extract cuDNN
          Expand-Archive -Path "gpu-libs/cudnn.zip" -DestinationPath "cudnn-extract" -Force
          Get-ChildItem -Path "cudnn-extract" -Recurse -Filter "*.dll" | Copy-Item -Destination "lib-staging/" -ErrorAction SilentlyContinue

          # Note: TensorRT is NOT bundled due to GitHub's 2GB release asset limit
          # Users can optionally download from https://github.com/NVIDIA/TensorRT

          # List collected DLLs
          Write-Host "=== Collected DLLs ==="
          Get-ChildItem lib-staging/

          # Verify critical libraries were extracted
          $requiredDlls = @(
            "onnxruntime.dll",
            "onnxruntime_providers_cuda.dll",
            "onnxruntime_providers_shared.dll",
            "cudart64_12.dll",
            "cublas64_12.dll",
            "cublasLt64_12.dll",
            "cufft64_11.dll",
            "cudnn64_9.dll",
            "nvrtc64_120_0.dll",
            "nvJitLink_120_0.dll"
          )

          $missing = @()
          foreach ($dll in $requiredDlls) {
            if (-not (Test-Path "lib-staging/$dll")) {
              $missing += $dll
            }
          }

          if ($missing.Count -gt 0) {
            Write-Host "ERROR: Required libraries not found:"
            $missing | ForEach-Object { Write-Host "  - $_" }
            exit 1
          }

          Write-Host "All required libraries present"

          # Clean up extracted directories to save space (keep only lib-staging and ort-extract for build)
          Remove-Item -Recurse -Force "cuda_cudart-extract" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "libcublas-extract" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "libcufft-extract" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "cuda_nvrtc-extract" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "libnvjitlink-extract" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "cudnn-extract" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "ort-extract" -ErrorAction SilentlyContinue

          # CRITICAL: Delete downloaded archives to free disk space
          Remove-Item -Recurse -Force "gpu-libs" -ErrorAction SilentlyContinue
          Write-Host "Disk space after cleanup:"
          Get-PSDrive C | Select-Object Free, Used

      - name: Build release binary (CUDA)
        shell: pwsh
        env:
          ORT_LIB_LOCATION: ${{ github.workspace }}/lib-staging
        run: cargo build --release --features cuda --target ${{ env.TARGET }}

      - name: Download Visual C++ Redistributable
        shell: pwsh
        run: |
          # Download VC++ Redistributable for bundling with installer
          # This is required by onnxruntime.dll and other native libraries
          Invoke-WebRequest -Uri "https://aka.ms/vs/17/release/vc_redist.x64.exe" -OutFile "vc_redist.x64.exe"
          Write-Host "Downloaded VC++ Redistributable"

      - name: Prepare artifact
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path dist

          # Copy binary
          Copy-Item "target/${{ env.TARGET }}/release/birda.exe" -Destination "dist/"

          # Copy GPU DLLs to same directory as executable (Windows searches exe directory)
          Copy-Item "lib-staging/*.dll" -Destination "dist/"

          # Copy VC++ Redistributable for installer
          Copy-Item "vc_redist.x64.exe" -Destination "dist/"

          # Copy documentation
          Copy-Item "README.md" -Destination "dist/"
          Copy-Item "LICENSE" -Destination "dist/" -ErrorAction SilentlyContinue
          Copy-Item "THIRD_PARTY_LICENSES.txt" -Destination "dist/"

          # Create archive (include version in filename, exclude vc_redist for ZIP - it's only for installer)
          Get-ChildItem "dist/*" -Exclude "vc_redist.x64.exe" | Compress-Archive -DestinationPath "${{ env.ARTIFACT }}-${{ github.ref_name }}.zip"

      - name: Build installer with Inno Setup
        shell: pwsh
        run: |
          # Get version from Cargo.toml
          $version = (Select-String -Path "Cargo.toml" -Pattern '^version = "(.+)"' | ForEach-Object { $_.Matches.Groups[1].Value })
          Write-Host "Building installer for version: $version"

          # Inno Setup is pre-installed on Windows runners
          & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" `
            /DMyAppVersion="$version" `
            /O"." `
            /F"${{ env.ARTIFACT }}-${{ github.ref_name }}-setup" `
            "installer\windows\birda.iss"

      - name: Upload ZIP artifact
        uses: actions/upload-artifact@v6
        with:
          name: ${{ env.ARTIFACT }}
          path: ${{ env.ARTIFACT }}-${{ github.ref_name }}.zip

      - name: Upload installer artifact
        uses: actions/upload-artifact@v6
        with:
          name: ${{ env.ARTIFACT }}-setup
          path: ${{ env.ARTIFACT }}-${{ github.ref_name }}-setup.exe

  # ==========================================================================
  # Create GitHub Release with all artifacts
  # ==========================================================================
  release:
    name: Create Release
    needs: [build-cpu, build-gpu-linux, build-gpu-windows, sign-and-notarize-macos]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v6

      - name: Download all artifacts
        uses: actions/download-artifact@v7
        with:
          path: artifacts

      - name: List artifacts
        run: find artifacts -type f -o -type l | head -100

      - name: Create CPU archives
        run: |
          VERSION="${{ github.ref_name }}"

          # Create tar.gz for Linux CPU (include version in filename)
          if [ -d "artifacts/birda-linux-x64" ]; then
            cd artifacts/birda-linux-x64
            tar -czvf ../birda-linux-x64-${VERSION}.tar.gz *
            cd ../..
          fi

          # Create zip for Windows CPU (include version in filename)
          if [ -d "artifacts/birda-windows-x64" ]; then
            cd artifacts/birda-windows-x64
            zip -r ../birda-windows-x64-${VERSION}.zip *
            cd ../..
          fi

          # Note: macOS archives are created by sign-and-notarize-macos job

          echo "=== Created archives ==="
          ls -la artifacts/*.tar.gz artifacts/*.zip 2>/dev/null || true

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true
          body: |
            ## Download Options

            | Package | Description |
            |---------|-------------|
            | `birda-linux-x64-${{ github.ref_name }}.tar.gz` | Linux CPU-only |
            | `birda-windows-x64-${{ github.ref_name }}.zip` | Windows CPU-only |
            | `birda-macos-arm64-${{ github.ref_name }}.dmg` | **macOS Apple Silicon (Signed & Notarized DMG)** |
            | `birda-macos-arm64-${{ github.ref_name }}-signed.tar.gz` | macOS Apple Silicon (Signed & Notarized tar.gz) |
            | `birda-linux-x64-cuda-${{ github.ref_name }}.tar.gz` | Linux with GPU support (bundled CUDA) |
            | `birda-windows-x64-cuda-${{ github.ref_name }}.zip` | Windows with GPU support (bundled CUDA) |
            | `birda-windows-x64-cuda-${{ github.ref_name }}-setup.exe` | Windows GPU installer (adds to PATH) |

            ### macOS Installation

            **DMG (Recommended):** Download the `.dmg` file and drag to Applications folder. The app is signed and notarized by Apple - no Gatekeeper warnings.

            **tar.gz:** For command-line users and package managers (Homebrew). Also signed and notarized.

            Both formats include the same signed and notarized binary with hardened runtime enabled for maximum security.

            ### GPU Builds

            GPU builds include bundled ONNX Runtime, CUDA, and cuDNN libraries - no separate installation required.

            **Windows Installer:** Use the `-setup.exe` for automatic installation with optional PATH configuration.

            **Portable:** Extract ZIP/tar.gz and run `birda` directly.

            **Requirements:** NVIDIA GPU with CUDA compute capability 5.0+

            ### TensorRT Support (Optional)

            For maximum GPU performance (~2x speedup over CUDA), install TensorRT separately:
            1. Download TensorRT for CUDA 12.x from [NVIDIA TensorRT](https://github.com/NVIDIA/TensorRT#downloading-tensorrt-build)
            2. Copy the TensorRT DLLs/libs to the birda installation directory
            3. Run with `--tensorrt` flag

            See [THIRD_PARTY_LICENSES.txt](THIRD_PARTY_LICENSES.txt) for bundled library licenses.
          files: |
            artifacts/**/*.tar.gz
            artifacts/**/*.zip
            artifacts/**/*.dmg
            artifacts/**/*-setup.exe

      - name: Scan release assets with VirusTotal
        continue-on-error: true
        uses: cssnr/virustotal-action@v1
        with:
          vt_api_key: ${{ secrets.VT_API_KEY }}
          release_id: ${{ steps.create_release.outputs.id }}

      - name: Update major version tag
        run: |
          VERSION="${{ github.ref_name }}"
          MAJOR=$(echo "$VERSION" | cut -d. -f1)

          # Dereference to commit to avoid tag-of-a-tag with annotated tags
          COMMIT=$(git rev-parse "${VERSION}^{commit}")
          echo "Updating major version tag: $MAJOR -> $COMMIT (from $VERSION)"
          git tag -f "$MAJOR" "$COMMIT"
          git push origin "$MAJOR" --force
