//! Integration test for clip extraction.

use std::io::Write;
use std::path::PathBuf;
use std::process::Command;

use tempfile::TempDir;

#[test]
#[ignore = "requires audio file"]
fn test_clip_command_extracts_clips() {
    // This test requires a real audio file to be present
    // It's marked as ignored by default

    let temp_dir = TempDir::new().unwrap();

    // Create a mock detection CSV
    let csv_path = temp_dir.path().join("test.wav.BirdNET.results.csv");
    let mut csv_file = std::fs::File::create(&csv_path).unwrap();
    writeln!(
        csv_file,
        "Start (s),End (s),Scientific name,Common name,Confidence"
    )
    .unwrap();
    writeln!(csv_file, "0.0,3.0,Parus major,Great Tit,0.85").unwrap();

    let output = Command::new(env!("CARGO_BIN_EXE_birda"))
        .args([
            "clip",
            csv_path.to_str().unwrap(),
            "--output",
            temp_dir.path().join("clips").to_str().unwrap(),
        ])
        .output()
        .expect("failed to execute birda clip");

    // Check that the command ran (may fail due to missing audio, which is expected)
    assert!(output.status.success() || String::from_utf8_lossy(&output.stderr).contains("audio"));
}

#[test]
fn test_clip_help_displays() {
    let output = Command::new(env!("CARGO_BIN_EXE_birda"))
        .args(["clip", "--help"])
        .output()
        .expect("failed to execute birda clip --help");

    let stdout = String::from_utf8_lossy(&output.stdout);

    assert!(output.status.success());
    assert!(stdout.contains("Extract audio clips"));
    assert!(stdout.contains("--confidence"));
    assert!(stdout.contains("--pre"));
    assert!(stdout.contains("--post"));
    assert!(stdout.contains("--base-dir"));
}

/// CSV round-trip test: verify clipper can parse CSV files generated by birda's output writers.
/// This ensures the integration between analyze output and clip input is seamless.
#[test]
fn test_csv_roundtrip_parse() {
    use birda::clipper::parse_detection_file;
    use birda::output::{CsvWriter, Detection, DetectionMetadata, OutputWriter};

    let temp_dir = TempDir::new().unwrap();
    let csv_path = temp_dir.path().join("roundtrip.BirdNET.results.csv");

    // Create detections using birda's output types
    let detections = vec![
        Detection {
            file_path: PathBuf::from("test.wav"),
            start_time: 0.0,
            end_time: 3.0,
            scientific_name: "Parus major".to_string(),
            common_name: "Great Tit".to_string(),
            confidence: 0.8542,
            metadata: DetectionMetadata::default(),
        },
        Detection {
            file_path: PathBuf::from("test.wav"),
            start_time: 15.0,
            end_time: 18.0,
            scientific_name: "Cyanistes caeruleus".to_string(),
            common_name: "Eurasian Blue Tit".to_string(),
            confidence: 0.7123,
            metadata: DetectionMetadata::default(),
        },
    ];

    // Write using birda's CSV writer (no extra columns, no BOM for simplicity)
    let mut writer = CsvWriter::new(&csv_path, vec![], false).unwrap();
    writer.write_header().unwrap();
    for detection in &detections {
        writer.write_detection(detection).unwrap();
    }
    writer.finalize().unwrap();

    // Parse back using clipper's parser
    let parsed = parse_detection_file(&csv_path).unwrap();

    assert_eq!(parsed.len(), 2);
    assert_eq!(parsed[0].scientific_name, "Parus major");
    assert_eq!(parsed[1].scientific_name, "Cyanistes caeruleus");
    assert!((parsed[0].confidence - 0.8542).abs() < 0.001);
}
