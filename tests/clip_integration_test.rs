//! Integration test for clip extraction.

use std::io::Write;
use std::path::PathBuf;
use std::process::Command;

use hound::{SampleFormat, WavSpec, WavWriter};
use tempfile::TempDir;

/// Create a dummy WAV file with silence for testing.
fn create_test_wav(path: &std::path::Path, duration_secs: u32, sample_rate: u32) {
    let spec = WavSpec {
        channels: 1,
        sample_rate,
        bits_per_sample: 16,
        sample_format: SampleFormat::Int,
    };

    let mut writer = WavWriter::create(path, spec).unwrap();

    // Write silence (zeros) for the specified duration
    let num_samples = sample_rate * duration_secs;
    for _ in 0..num_samples {
        writer.write_sample(0i16).unwrap();
    }

    writer.finalize().unwrap();
}

#[test]
fn test_clip_command_extracts_clips() {
    let temp_dir = TempDir::new().unwrap();

    // Create a test WAV file (5 seconds of silence at 48kHz)
    let wav_path = temp_dir.path().join("test.wav");
    create_test_wav(&wav_path, 5, 48000);

    // Create a detection CSV pointing to the WAV
    let csv_path = temp_dir.path().join("test.wav.BirdNET.results.csv");
    let mut csv_file = std::fs::File::create(&csv_path).unwrap();
    writeln!(
        csv_file,
        "Start (s),End (s),Scientific name,Common name,Confidence"
    )
    .unwrap();
    writeln!(csv_file, "0.0,3.0,Parus major,Great Tit,0.85").unwrap();

    let output_dir = temp_dir.path().join("clips");

    let output = Command::new(env!("CARGO_BIN_EXE_birda"))
        .args([
            "clip",
            csv_path.to_str().unwrap(),
            "--output",
            output_dir.to_str().unwrap(),
            "--pre",
            "0",
            "--post",
            "0",
        ])
        .output()
        .expect("failed to execute birda clip");

    // Check that the command succeeded
    assert!(
        output.status.success(),
        "clip command failed: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Check that the output directory was created with species subdirectory
    let species_dir = output_dir.join("Parus major");
    assert!(species_dir.exists(), "Species directory should exist");

    // Check that at least one clip was extracted
    let clips: Vec<_> = std::fs::read_dir(&species_dir)
        .unwrap()
        .filter_map(Result::ok)
        .filter(|e| e.path().extension().is_some_and(|ext| ext == "wav"))
        .collect();

    assert!(!clips.is_empty(), "Should have extracted at least one clip");
}

#[test]
fn test_clip_help_displays() {
    let output = Command::new(env!("CARGO_BIN_EXE_birda"))
        .args(["clip", "--help"])
        .output()
        .expect("failed to execute birda clip --help");

    let stdout = String::from_utf8_lossy(&output.stdout);

    assert!(output.status.success());
    assert!(stdout.contains("Extract audio clips"));
    assert!(stdout.contains("--confidence"));
    assert!(stdout.contains("--pre"));
    assert!(stdout.contains("--post"));
    assert!(stdout.contains("--base-dir"));
}

/// CSV round-trip test: verify clipper can parse CSV files generated by birda's output writers.
/// This ensures the integration between analyze output and clip input is seamless.
#[test]
fn test_csv_roundtrip_parse() {
    use birda::clipper::parse_detection_file;
    use birda::output::{CsvWriter, Detection, DetectionMetadata, OutputWriter};

    let temp_dir = TempDir::new().unwrap();
    let csv_path = temp_dir.path().join("roundtrip.BirdNET.results.csv");

    // Create detections using birda's output types
    let detections = vec![
        Detection {
            file_path: PathBuf::from("test.wav"),
            start_time: 0.0,
            end_time: 3.0,
            scientific_name: "Parus major".to_string(),
            common_name: "Great Tit".to_string(),
            confidence: 0.8542,
            metadata: DetectionMetadata::default(),
        },
        Detection {
            file_path: PathBuf::from("test.wav"),
            start_time: 15.0,
            end_time: 18.0,
            scientific_name: "Cyanistes caeruleus".to_string(),
            common_name: "Eurasian Blue Tit".to_string(),
            confidence: 0.7123,
            metadata: DetectionMetadata::default(),
        },
    ];

    // Write using birda's CSV writer (no extra columns, no BOM for simplicity)
    let mut writer = CsvWriter::new(&csv_path, vec![], false).unwrap();
    writer.write_header().unwrap();
    for detection in &detections {
        writer.write_detection(detection).unwrap();
    }
    writer.finalize().unwrap();

    // Parse back using clipper's parser
    let parsed = parse_detection_file(&csv_path).unwrap();

    assert_eq!(parsed.len(), 2);
    assert_eq!(parsed[0].scientific_name, "Parus major");
    assert_eq!(parsed[1].scientific_name, "Cyanistes caeruleus");
    assert!((parsed[0].confidence - 0.8542).abs() < 0.001);
}
